To generate a layout for the graph while keeping the community structure clear, we can use a community detection algorithm to partition the graph into communities and then assign positions to the nodes based on their community membership. Here, we will use the Louvain method for community detection, which is a popular algorithm for detecting communities in large networks.

The layout will be generated by placing nodes within the same community close to each other, while ensuring that different communities are spaced apart. The positions will be assigned in a grid-like fashion, with each community occupying a distinct region.

Below is the Python code to achieve this:

```python
import json
import random
from collections import defaultdict

# Function to detect communities using the Louvain method
def louvain_communities(edge_list):
    import community as community_louvain
    import networkx as nx
    
    G = nx.Graph()
    G.add_edges_from(edge_list)
    partition = community_louvain.best_partition(G)
    
    # Create a dictionary to map communities to nodes
    communities = defaultdict(list)
    for node, comm in partition.items():
        communities[comm].append(node)
    
    return list(communities.values())

# Function to generate positions for nodes based on communities
def generate_layout(edge_list):
    communities = louvain_communities(edge_list)
    
    # Assign positions to nodes
    positions = {}
    community_positions = {}
    
    # Calculate the number of communities
    num_communities = len(communities)
    
    # Determine the grid size based on the number of communities
    grid_size = int(num_communities ** 0.5) + 1
    
    # Assign a position to each community
    for i, comm in enumerate(communities):
        row = i // grid_size
        col = i % grid_size
        community_positions[i] = (col * 100, row * 100)  # Spacing between communities
    
    # Assign positions to nodes within each community
    for i, comm in enumerate(communities):
        comm_pos = community_positions[i]
        for j, node in enumerate(comm):
            positions[node] = (comm_pos[0] + random.uniform(-10, 10), comm_pos[1] + random.uniform(-10, 10))
    
    return positions

# Example usage
edge_list = [(0, 2), (0, 3), (0, 5), (0, 7), (0, 8), (0, 11), (0, 14), (0, 18), (0, 22), (0, 25), 
             (1, 2), (1, 5), (1, 7), (1, 8), (1, 9), (1, 11), (1, 12), (1, 13), (1, 14), (1, 16), 
             (1, 24), (2, 3), (2, 5), (2, 6), (2, 9), (2, 16), (2, 17), (2, 18), (2, 24), (2, 25), 
             (2, 60), (2, 69), (3, 8), (3, 13), (3, 15), (3, 19), (4, 6), (4, 8), (4, 9), (4, 10), 
             (4, 14), (4, 15), (4, 16), (4, 19), (4, 20), (4, 23), (5, 7), (5, 8), (5, 9), (5, 15), 
             (5, 17), (5, 24), (5, 50), (5, 65), (6, 7), (6, 8), (6, 9), (6, 10), (6, 15), (6, 16), 
             (6, 17), (6, 18), (6, 19), (6, 20), (6, 22), (7, 9), (7, 11), (7, 19), (7, 20), (7, 21), 
             (7, 22), (7, 24), (8, 14), (8, 18), (8, 20), (8, 21), (8, 22), (8, 25), (9, 11), (9, 14), 
             (9, 20), (9, 22), (9, 23), (9, 25), (10, 15), (10, 19), (10, 21), (10, 24), (11, 13), 
             (11, 16), (11, 18), (11, 19), (11, 20), (11, 21), (11, 25), (12, 14), (12, 15), (12, 16), 
             (12, 21), (12, 22), (12, 23), (13, 16), (13, 18), (13, 19), (13, 20), (13, 21), (13, 22), 
             (13, 24), (13, 25), (13, 46), (14, 19), (14, 21), (14, 24), (15, 16), (15, 25), (15, 59), 
             (16, 17), (16, 21), (16, 23), (16, 24), (17, 19), (17, 21), (17, 22), (17, 24), (17, 25), 
             (18, 22), (18, 24), (18, 42), (19, 20), (19, 24), (19, 72), (20, 24), (21, 23), (21, 24), 
             (22, 25), (23, 24), (23, 43), (24, 25), (26, 27), (26, 28), (26, 29), (26, 30), (26, 35), 
             (26, 40), (26, 44), (26, 47), (27, 33), (27, 41), (27, 42), (27, 43), (27, 45), (27, 47), 
             (28, 30), (28, 34), (28, 35), (28, 36), (28, 38), (28, 40), (28, 41), (28, 42), (28, 46), 
             (28, 48), (28, 50), (29, 31), (29, 32), (29, 35), (29, 36), (29, 38), (29, 39), (29, 41), 
             (29, 43), (29, 45), (29, 47), (29, 49), (30, 48), (31, 37), (31, 41), (31, 47), (31, 49), 
             (32, 33), (32, 34), (32, 35), (32, 36), (32, 37), (32, 44), (32, 48), (32, 49), (33, 40), 
             (33, 41), (33, 42), (33, 43), (33, 46), (33, 47), (33, 48), (33, 49), (34, 38), (34, 39), 
             (34, 42), (34, 46), (34, 47), (34, 48), (34, 49), (35, 37), (35, 38), (35, 42), (35, 44), 
             (35, 46), (35, 48), (36, 37), (36, 38), (36, 40), (36, 42), (36, 44), (36, 46), (36, 47), 
             (36, 49), (36, 50), (37, 38), (37, 43), (37, 44), (38, 42), (38, 44), (38, 46), (39, 41), 
             (39, 42), (39, 44), (39, 45), (39, 50), (40, 41), (40, 42), (40, 43), (40, 44), (41, 43), 
             (41, 44), (41, 48), (41, 49), (41, 50), (42, 44), (42, 46), (42, 47), (42, 49), (43, 46), 
             (43, 47), (43, 49), (44, 45), (44, 50), (44, 68), (45, 50), (46, 47), (46, 49), (46, 50), 
             (46, 75), (50, 71), (51, 52), (51, 53), (51, 57), (51, 64), (51, 65), (51, 67), (51, 73), 
             (51, 74), (52, 58), (52, 59), (52, 60), (52, 63), (52, 67), (52, 69), (53, 54), (53, 56), 
             (53, 58), (53, 60), (53, 62), (53, 64), (53, 67), (53, 71), (53, 74), (54, 58), (54, 61), 
             (54, 62), (54, 64), (54, 65), (54, 66), (54, 71), (54, 72), (55, 57), (55, 58), (55, 59), 
             (55, 60), (55, 62), (55, 65), (55, 66), (55, 67), (55, 70), (56, 57), (56, 59), (56, 60), 
             (56, 61), (56, 66), (56, 68), (56, 69), (56, 70), (57, 60), (57, 62), (57, 63), (57, 65), 
             (57, 69), (57, 71), (58, 60), (58, 61), (58, 62), (58, 64), (58, 67), (58, 71), (58, 72), 
             (58, 73), (58, 74), (58, 75), (59, 65), (59, 69), (59, 70), (59, 71), (59, 72), (59, 73), 
             (60, 61), (60, 64), (60, 68), (60, 69), (60, 72), (60, 74), (61, 63), (61, 75), (62, 64), 
             (62, 68), (62, 70), (62, 72), (62, 74), (63, 69), (64, 65), (64, 66), (64, 68), (64, 70), 
             (65, 67), (65, 71), (65, 73), (66, 68), (66, 69), (66, 70), (66, 72), (66, 74), (66, 75), 
             (67, 69), (67, 73), (68, 72), (68, 73), (68, 75), (70, 73), (71, 73), (71, 75), (73, 75), 
             (74, 75)]

# Generate the layout
layout = generate_layout(edge_list)

# Convert the layout to JSON format
layout_json = json.dumps(layout, indent=4)
print(layout_json)
```

### Explanation:
1. **Community Detection**: The `louvain_communities` function uses the Louvain method to detect communities in the graph. It returns a list of communities, where each community is a list of nodes.

2. **Layout Generation**: The `generate_layout` function assigns positions to nodes based on their community membership. Each community is placed in a distinct region of the grid, and nodes within the same community are placed close to each other with some random variation.

3. **Output**: The final layout is converted to JSON format and printed.

### Note:
- The `community` module used in the code is part of the `python-louvain` package, which can be installed via `pip install python-louvain`.
- The positions are assigned in a grid-like fashion, with each community occupying a distinct region. The spacing between communities is set to 100 units, and nodes within the same community are placed within a 20-unit range around the community's center.

This code will generate a layout that visually represents the community structure of the graph.