To generate a layout for the graph while keeping the community structure clear, we can use a community detection algorithm to partition the graph into communities and then assign positions to the nodes based on their community membership. Here, we will use the Louvain method for community detection, which is a popular algorithm for detecting communities in large networks.

The layout will be generated by placing nodes in a circular fashion around the center of their respective communities. The communities themselves will be placed in a circular layout around the center of the graph.

Here is the Python code to achieve this:

```python
import json
import random
import math
from collections import defaultdict

# Edge list of the graph
edge_list = [(0, 1), (0, 3), (0, 4), (0, 5), (1, 3), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5), (4, 14), (6, 7), (6, 8), (6, 9), (6, 10), (7, 8), (7, 9), (7, 10), (8, 9), (8, 10), (8, 11), (9, 10), (11, 12), (11, 13), (11, 14), (11, 15), (12, 13), (12, 14), (12, 15), (13, 15), (14, 15), (15, 17), (16, 18), (16, 19), (16, 20), (17, 18), (17, 19), (17, 20), (18, 19), (18, 20), (19, 20)]

# Function to detect communities using the Louvain method
def louvain_communities(edge_list):
    from community import community_louvain
    import networkx as nx
    
    G = nx.Graph()
    G.add_edges_from(edge_list)
    partition = community_louvain.best_partition(G)
    
    communities = defaultdict(list)
    for node, community_id in partition.items():
        communities[community_id].append(node)
    
    return list(communities.values())

# Function to generate positions for nodes in a circular layout
def circular_layout(nodes, center, radius):
    positions = {}
    angle = 2 * math.pi / len(nodes)
    for i, node in enumerate(nodes):
        x = center[0] + radius * math.cos(i * angle)
        y = center[1] + radius * math.sin(i * angle)
        positions[node] = (x, y)
    return positions

# Detect communities
communities = louvain_communities(edge_list)

# Generate positions for each community
layout = {}
community_radius = 2.0  # Radius for nodes within a community
community_spacing = 5.0  # Distance between communities

for i, community in enumerate(communities):
    center = (community_spacing * math.cos(2 * math.pi * i / len(communities)),
              (community_spacing * math.sin(2 * math.pi * i / len(communities)))
    community_positions = circular_layout(community, center, community_radius)
    layout.update(community_positions)

# Convert layout to JSON format
layout_json = json.dumps(layout, indent=4)
print(layout_json)
```

### Explanation:
1. **Community Detection**: The `louvain_communities` function uses the Louvain method to detect communities in the graph. It returns a list of communities, where each community is a list of nodes.

2. **Circular Layout**: The `circular_layout` function generates positions for nodes in a circular fashion around a given center with a specified radius.

3. **Community Placement**: Each community is placed in a circular layout around the center of the graph. The distance between communities is controlled by `community_spacing`.

4. **Output**: The final layout is converted to JSON format and printed.

### Note:
- The `community` module used in the code is part of the `python-louvain` package, which you can install using `pip install python-louvain`.
- The code does not use any existing graph layout algorithms like `nx.spring_layout()` or `nx.circular_layout()`. Instead, it manually calculates the positions based on community structure.
- The output is a JSON object where each node is mapped to its position in the layout.