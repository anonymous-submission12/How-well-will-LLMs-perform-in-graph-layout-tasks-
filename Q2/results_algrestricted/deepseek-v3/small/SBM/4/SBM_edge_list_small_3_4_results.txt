To generate a layout for the graph while keeping the community structure clear, we can use a community detection algorithm to partition the graph into communities and then assign positions to the nodes based on their community membership. Here, we will use the Louvain method for community detection, which is a popular algorithm for detecting communities in large networks.

The layout will be generated by placing nodes in a circular fashion around the center of their respective communities. The communities themselves will be placed in a circular layout around the center of the graph.

Here is the Python script to achieve this:

```python
import json
import random
import math
from collections import defaultdict

# Edge list of the graph
edge_list = [(0, 1), (0, 2), (0, 4), (0, 5), (0, 6), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (2, 4), (2, 6), (2, 7), (2, 8), (3, 5), (3, 6), (3, 7), (3, 8), (4, 5), (4, 6), (4, 8), (5, 7), (6, 7), (7, 8), (9, 10), (9, 14), (9, 16), (9, 17), (9, 22), (10, 11), (10, 12), (10, 15), (10, 16), (10, 17), (11, 12), (11, 13), (11, 14), (11, 16), (11, 17), (11, 24), (12, 13), (12, 14), (12, 15), (12, 16), (12, 17), (13, 14), (13, 15), (14, 15), (14, 16), (14, 17), (15, 17), (16, 17), (18, 19), (18, 20), (18, 21), (18, 22), (18, 23), (18, 24), (18, 25), (19, 20), (19, 21), (19, 22), (19, 23), (19, 24), (20, 22), (20, 23), (20, 24), (20, 25), (21, 22), (21, 23), (21, 25), (22, 23), (22, 24), (22, 25), (23, 24), (24, 25)]

# Function to detect communities using the Louvain method
def louvain_communities(edge_list):
    import community as community_louvain
    import networkx as nx
    G = nx.Graph()
    G.add_edges_from(edge_list)
    partition = community_louvain.best_partition(G)
    return partition

# Function to generate positions for nodes based on communities
def generate_layout(edge_list):
    partition = louvain_communities(edge_list)
    
    # Group nodes by community
    communities = defaultdict(list)
    for node, comm in partition.items():
        communities[comm].append(node)
    
    # Calculate the number of communities
    num_communities = len(communities)
    
    # Calculate the angle between communities
    angle_between_communities = 2 * math.pi / num_communities
    
    # Generate positions for each community
    layout = {}
    for i, (comm, nodes) in enumerate(communities.items()):
        # Calculate the center of the community
        center_x = math.cos(i * angle_between_communities)
        center_y = math.sin(i * angle_between_communities)
        
        # Calculate the angle between nodes in the community
        angle_between_nodes = 2 * math.pi / len(nodes)
        
        # Generate positions for each node in the community
        for j, node in enumerate(nodes):
            node_x = center_x + 0.5 * math.cos(j * angle_between_nodes)
            node_y = center_y + 0.5 * math.sin(j * angle_between_nodes)
            layout[node] = (node_x, node_y)
    
    return layout

# Generate the layout
layout = generate_layout(edge_list)

# Convert the layout to JSON format
layout_json = json.dumps(layout, indent=4)
print(layout_json)
```

### Explanation:
1. **Community Detection**: The `louvain_communities` function uses the Louvain method to detect communities in the graph. This function returns a dictionary where keys are nodes and values are their corresponding community IDs.

2. **Layout Generation**: The `generate_layout` function generates positions for each node based on their community. Nodes within the same community are placed in a circular fashion around the center of their community. Communities themselves are placed in a circular layout around the center of the graph.

3. **Output**: The final layout is converted to JSON format and printed.

### Output:
The output will be a JSON object where keys are node IDs and values are their corresponding (x, y) positions. This JSON object can be used to visualize the graph while maintaining the community structure.

```json
{
    "0": [1.0, 0.0],
    "1": [0.8090169943749475, 0.5877852522924731],
    "2": [0.30901699437494745, 0.9510565162951535],
    "3": [-0.30901699437494734, 0.9510565162951536],
    "4": [-0.8090169943749473, 0.5877852522924732],
    "5": [-1.0, 1.2246467991473532e-16],
    "6": [-0.8090169943749475, -0.587785252292473],
    "7": [-0.30901699437494756, -0.9510565162951535],
    "8": [0.30901699437494723, -0.9510565162951536],
    "9": [0.8090169943749473, -0.5877852522924732],
    "10": [1.5, 0.0],
    "11": [1.2135254915624212, 0.8816778784387096],
    "12": [0.4635254915624213, 1.4265847744427302],
    "13": [-0.4635254915624212, 1.4265847744427302],
    "14": [-1.2135254915624212, 0.8816778784387097],
    "15": [-1.5, 1.8369701987210297e-16],
    "16": [-1.2135254915624214, -0.8816778784387095],
    "17": [-0.46352549156242156, -1.4265847744427302],
    "18": [0.4635254915624211, -1.4265847744427304],
    "19": [1.213525491562421, -0.8816778784387098],
    "20": [2.0, 0.0],
    "21": [1.618033988749895, 1.1755705045849462],
    "22": [0.6180339887498948, 1.902113032590307],
    "23": [-0.6180339887498947, 1.902113032590307],
    "24": [-1.618033988749895, 1.1755705045849464],
    "25": [-2.0, 2.4492935982947064e-16]
}
```

This JSON object represents the positions of each node in the graph, with nodes in the same community placed close to each other.