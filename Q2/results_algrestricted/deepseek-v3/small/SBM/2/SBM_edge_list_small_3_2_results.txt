To generate a graph layout that maintains consistency between Euclidean distance and graph-theoretic distance, we can use a force-directed layout approach. This approach simulates physical forces between nodes and edges to position the nodes in a way that minimizes edge crossings and keeps connected nodes close together.

Below is a Python script that implements a simple force-directed layout algorithm. The script will output the graph layout in JSON format.

```python
import json
import random
import math

# Define the graph as an edge list
edge_list = [
    (0, 1), (0, 2), (0, 4), (0, 5), (0, 6), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9),
    (2, 4), (2, 6), (2, 7), (2, 8), (3, 5), (3, 6), (3, 7), (3, 8), (4, 5), (4, 6), (4, 8), (5, 7), (6, 7),
    (7, 8), (9, 10), (9, 14), (9, 16), (9, 17), (9, 22), (10, 11), (10, 12), (10, 15), (10, 16), (10, 17),
    (11, 12), (11, 13), (11, 14), (11, 16), (11, 17), (11, 24), (12, 13), (12, 14), (12, 15), (12, 16),
    (12, 17), (13, 14), (13, 15), (14, 15), (14, 16), (14, 17), (15, 17), (16, 17), (18, 19), (18, 20),
    (18, 21), (18, 22), (18, 23), (18, 24), (18, 25), (19, 20), (19, 21), (19, 22), (19, 23), (19, 24),
    (20, 22), (20, 23), (20, 24), (20, 25), (21, 22), (21, 23), (21, 25), (22, 23), (22, 24), (22, 25),
    (23, 24), (24, 25)
]

# Initialize node positions randomly
nodes = set()
for edge in edge_list:
    nodes.add(edge[0])
    nodes.add(edge[1])
nodes = list(nodes)

# Initialize positions randomly
positions = {node: (random.uniform(0, 100), random.uniform(0, 100)) for node in nodes}

# Parameters for the force-directed layout
k = 1.0  # Optimal distance between nodes
iterations = 100
temperature = 100.0
cooling_factor = 0.95

# Force-directed layout algorithm
for iteration in range(iterations):
    # Calculate repulsive forces
    for i in range(len(nodes)):
        for j in range(i + 1, len(nodes)):
            node1 = nodes[i]
            node2 = nodes[j]
            x1, y1 = positions[node1]
            x2, y2 = positions[node2]
            dx = x2 - x1
            dy = y2 - y1
            distance = math.sqrt(dx * dx + dy * dy)
            if distance > 0:
                force = (k * k) / distance
                positions[node1] = (x1 - force * dx / distance, y1 - force * dy / distance)
                positions[node2] = (x2 + force * dx / distance, y2 + force * dy / distance)

    # Calculate attractive forces
    for edge in edge_list:
        node1 = edge[0]
        node2 = edge[1]
        x1, y1 = positions[node1]
        x2, y2 = positions[node2]
        dx = x2 - x1
        dy = y2 - y1
        distance = math.sqrt(dx * dx + dy * dy)
        if distance > 0:
            force = (distance * distance) / k
            positions[node1] = (x1 + force * dx / distance, y1 + force * dy / distance)
            positions[node2] = (x2 - force * dx / distance, y2 - force * dy / distance)

    # Cool down the temperature
    temperature *= cooling_factor

# Output the positions in JSON format
layout = {str(node): {"x": pos[0], "y": pos[1]} for node, pos in positions.items()}
print(json.dumps(layout, indent=4))
```

### Explanation:
1. **Initialization**: The nodes are initialized with random positions within a 100x100 grid.
2. **Force-Directed Layout**: The algorithm iteratively calculates repulsive forces between all pairs of nodes and attractive forces between connected nodes. The repulsive force pushes nodes apart, while the attractive force pulls connected nodes closer together.
3. **Cooling**: The temperature is reduced over time to allow the system to settle into a stable configuration.
4. **Output**: The final positions of the nodes are output in JSON format.

This script provides a basic implementation of a force-directed layout algorithm. You can further refine the parameters (e.g., `k`, `iterations`, `temperature`, `cooling_factor`) to achieve better results for your specific graph.